Para iImplementar una pantalla de Lockscreen, necesitamos trabajar la vista, esta esta ubicada en

/home/klvst3r/dev/laravel/travelblog/resources/views/lockscreen/index.blade.php


El cual es activado desde el dashboard con el link siguiente:

  <a href="{{ url('/lockscreen') }}" data-toggle="tooltip" data-placement="top" 
                title="Bloquear pantalla">  <span class="glyphicon glyphicon-eye-close" aria-hidden="true"></span>
              </a>

Como podemos ver este redirige hacia la ruta lockscreen, por ello en nuestroa rchivo de rutas tendremos lo siguiente:


Route::get('lockscreen', function(){
    return view('lockscreen.index');
});


con esto tenemos una activaci√≥n de la vista de lockscreen realmente proteja el acceso al dashboard y obligue al usuario a desbloquearla antes de continuar, necesitas una variable de control adicional en sesi√≥n y un middleware personalizado que act√∫e como "candado" para bloquear temporalmente todas las rutas sensibles (como /home, /dashboard, etc.) hasta que se desbloquee.


# Bloqueo de acceso al dashboard hasta desbloqueo.


El proceso parabloquear el usuario al dashboard es el siguiente:

1.  1. Agrega una variable de sesi√≥n en el lock

Cuando el usuario active el lockscreen, guarda en sesi√≥n una bandera como:
     locked = true.

Se puede hacer esto desde un controlador, por ejemplo:

Crear el controlador LockscreenController

    $ php artisan make:controller LockscreenController

Como deseamos que el controlador este dentro de una carpeta (namespace) llamada Lock, ejecutamos:

    $ php artisan make:controller Lock/LockscreenController

El namescpace sera:

namespace App\Http\Controllers\Lock;


Asi al usar las rutas o tras clases, debemos importarlo de la siguente manera:

use App\Http\Controllers\Lock\LockscreenController;




Luego en el controlador:

namespace App\Http\Controllers;

Vamos a usar el namespace siguiente:

namespace App\Http\Controllers\Lock;



use Illuminate\Http\Request;
use Illuminate\Support\Facades\Session;

class LockscreenController extends Controller
{
    public function show()
    {
        // Poner la bandera de bloqueo en sesi√≥n
        session(['locked' => true]);
        return view('lockscreen.index');
    }

    public function unlock(Request $request)
    {
        if (!auth()->check()) {
            return redirect()->route('login');
        }

        // Validar password del usuario logueado
        if (!\Hash::check($request->password, auth()->user()->password)) {
            return back()->withErrors(['password' => 'Contrase√±a incorrecta']);
        }

        // Desbloquear
        session()->forget('locked');
        return redirect('/home'); // o a donde quieras redirigir despu√©s del desbloqueo
    }
}


2. Crearlas rutas necesarias en el archivo de Rutas en web.php

// Mostrar lockscreen
Route::get('/lockscreen', [App\Http\Controllers\LockscreenController::class, 'show'])->name('lockscreen');

// Desbloquear
Route::post('/unlock', [App\Http\Controllers\LockscreenController::class, 'unlock'])->name('unlock');


3. Crea un Middleware personalizado: LockscreenMiddleware, con el comando:

    $ php artisan make:middleware LockscreenMiddleware



En app/Http/Middleware/LockscreenMiddleware.php

---
namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class LockscreenMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        if (auth()->check() && session('locked')) {
            // Evitar loop infinito si ya estamos en lockscreen
            if (!$request->is('lockscreen') && !$request->is('unlock')) {
                return redirect()->route('lockscreen');
            }
        }

        return $next($request);
    }
}



4. Reg√≠stralo en Kernel.php

En el archivo app/Http/Kernel.php, agregamos:

---
protected $routeMiddleware = [
    // ...
    'lockscreen' => \App\Http\Middleware\LockscreenMiddleware::class,
];


5. Prot√©gemos las rutas con este middleware

En las rutas donde queremos bloquear el acceso si est√° bloqueado:

Route::middleware(['auth', 'lockscreen'])->group(function () {
    Route::get('/home', [App\Http\Controllers\HomeController::class, 'index'])->name('home');
    // ...otras rutas protegidas
});


Detalle de este paso:

El paso 5 consiste en aplicar el middleware lockscreen a las rutas que se desean proteger, es decir, aquellas a las que solo se debe acceder si la sesi√≥n no est√° bloqueada.

¬øD√≥nde colocar esas l√≠neas?

Se deben colocar en el archivo de rutas routes/web.php, envolviendo las rutas que se quieren proteger. 

Por ejemplo, si el panel de control (dashboard) est√° en /home y se tienen otras rutas internas que se desean proteger con el lockscreen, se deber√≠a hacer as√≠:



use App\Http\Controllers\HomeController;
use Illuminate\Support\Facades\Route;

// Rutas p√∫blicas (sin protecci√≥n por lockscreen)
Route::get('/lockscreen', [App\Http\Controllers\Lock\LockscreenController::class, 'show'])->name('lockscreen');
Route::post('/unlock', [App\Http\Controllers\Lock\LockscreenController::class, 'unlock'])->name('unlock');

// Rutas protegidas por autenticaci√≥n y lockscreen
Route::middleware(['auth', 'lockscreen'])->group(function () {
    Route::get('/home', [HomeController::class, 'index'])->name('home');
    
    // Otras rutas protegidas aqu√≠
    // Route::get('/perfil', [PerfilController::class, 'index']);
});

¬øQu√© hace esto?

    auth: Verifica que el usuario est√© autenticado.

    lockscreen: Verifica que no est√© bloqueado por la pantalla de lockscreen.

    Si est√° bloqueado, lo redirige autom√°ticamente a /lockscreen seg√∫n tu middleware personalizado.







6. En tu vista del lockscreen (lockscreen.index):
El formulario ahora debe enviar al m√©todo unlock en el controlador,

<form action="{{ route('unlock') }}" method="POST" class="lockscreen-credentials">
  @csrf
  <div class="input-group">
    <input type="password" name="password" class="form-control" placeholder="Password" required>
    <div class="input-group-append">
      <button type="submit" class="btn">
        <i class="fa-solid fa-arrow-right text-muted"></i>
      </button>
    </div>
  </div>
</form>


Resultado Final:

    Cuando se entra a /lockscreen, la sesi√≥n guarda locked = true.

    Todas las rutas protegidas (como /home) redirigen a /lockscreen mientras esa variable exista.

    Al ingresar la contrase√±a correcta, se elimina locked y se vuelve a permitir el acceso normal.



Para este paso, que es el paso 6, que es enviar la contrase√±a ingresada en el formulario para desbloquear la pantalla y verificar las credenciales.

 Enviar el formulario al controlador

Actualmente, nuestro formulario tiene esta estructura:

<form class="lockscreen-credentials">
  <div class="input-group">
    <input type="password" class="form-control" placeholder="Password">
    <div class="input-group-append">
      <button type="submit" class="btn">
        <i class="fa fa-arrow-right"></i>
      </button>
    </div>
  </div>
</form>

 ¬øQu√© le falta?

    M√©todo POST

    Ruta de acci√≥n (a d√≥nde se env√≠a el formulario)

    Protecci√≥n CSRF

    Campo name="password" para que Laravel lo procese


Vamos a modificarlos de la siguiente manera:


<form class="lockscreen-credentials" method="POST" action="{{ route('unlock') }}">
  @csrf
  <div class="input-group">
    <input type="password" name="password" class="form-control" placeholder="Password" required>
    <div class="input-group-append">
      <button type="submit" class="btn">
        <i class="fa fa-arrow-right"></i>
      </button>
    </div>
  </div>
</form>




 ¬øQu√© hace esto?

    El formulario se enviar√° con m√©todo POST a la ruta unlock que se debes tener definida en web.php.

    Incluir @csrf para proteger contra ataques CSRF.

    El campo name="password" permitir√° al controlador recibir la contrase√±a y validarla.


Verificamos que la ruta exista en web.php

Debemos aseg√∫rarnos de tener en routes/web.php, el siguiente metodo:



    use App\Http\Controllers\Lock\LockscreenController;

    Route::post('/unlock', [LockscreenController::class, 'unlock'])->name('unlock');

 Y que debemos contar con nuestro m√©todo unlock() en LockscreenController, debe ser algo como esto:

        public function unlock(Request $request)
        {
            $request->validate([
                'password' => 'required',
            ]);

            if (Hash::check($request->password, auth()->user()->password)) {
                session(['locked' => false]); // desbloquea
                return redirect()->intended('/home'); // o a donde quieras volver
            }

            return back()->withErrors(['password' => 'Contrase√±a incorrecta']);
        }
            

Con eso, ya se tiene todo funcionando:

    Formulario funcional

    Ruta activa

    Middleware bloqueando

    Desbloqueo por contrase√±a            


Para mostrar el mensaje de error cuando la contrase√±a del lockscreen es incorrecta, solo necesitamos colocar ese bloque de Blade justo despu√©s del 

<div class="help-block text-center">.

En el fragmento con el bloque de error integrado:


Ubicaci√≥n correcta en tu lockscreen.index

Buscamos esta parte de nuestro c√≥digo:

    <div class="help-block text-center">
        Introduzca su password para recuperar su sesi√≥n
    </div>

Y colocamos inmediatamente debajo esto:

    @if ($errors->any())
        <div class="text-danger text-center mt-2">
            {{ $errors->first('password') }}
        </div>
    @endif

Resultado esperado

Quedar√≠a as√≠:

        <!-- Credenciales del lockscreen (contenido en el formulario) -->
            <form class="lockscreen-credentials" method="POST" action="{{ route('unlock') }}">
            @csrf
            <div class="input-group">
                <input type="password" name="password" class="form-control" placeholder="Password" required>
                <div class="input-group-append">
                <button type="submit" class="btn">
                    <i class="fa fa-arrow-right"></i>
                </button>
                </div>
            </div>
            </form>
            <!-- /.credenciales del lockscreen -->
        </div>

        {{-- Mostrar mensaje de errorcuanto el usuario introduzca la contrase√±a de manera incorrecta --}}
        @if ($errors->any())
            <div class="text-danger text-center mt-2">
                {{ $errors->first('password') }}
            </div>
        @endif



        <!-- /.item del lockscreen -->
        <div class="help-block text-center">
            Introduzca su password para recuperar su sesi√≥n
        </div>


Esto mostrar√° un mensaje como:

    "Contrase√±a incorrecta"

‚Ä¶cuando el usuario ingrese mal su password, gracias al retorno desde tu LockscreenController@unlock:

return back()->withErrors(['password' => 'Contrase√±a incorrecta']);    



Como no hemos eliminado el home para que funcione con el clousure, tenemos un detalle en nuestro controladore de Homecontroller ya que tenemos una ruta inicial llamada home que nos lleva al home y no al dashboard construido de la siguiente manera:

Route::get('home', function(){
    return view('admin.dashboard');
})->middleware('auth');

y en nuestra ruta protegida tamben en el homeController tenemos :

Route::middleware(['auth', 'lockscreen'])->group(function () {
    Route::get('/home', [HomeController::class, 'index'])->name('home');
    
    // Otras rutas protegidas aqu√≠
    // Route::get('/perfil', [PerfilController::class, 'index']);
});

Lo que queremos es que cuando se desbloquee la pantalla locscreen nos lleve a home que incluye el dashboard es decir a la ruta home pero que este protegida con el middleware


Problema:

Actualmente tenemos dos rutas distintas apuntando a /home:

    Esta ruta directa con un closure (no usa controlador):

        Route::get('home', function(){
            return view('admin.dashboard');
        })->middleware('auth');

Esta ruta que s√≠ usa el controlador y aplica tambi√©n el middleware lockscreen:

    Route::middleware(['auth', 'lockscreen'])->group(function () {
        Route::get('/home', [HomeController::class, 'index'])->name('home');
    });

Esto causa confusi√≥n y conflicto porque Laravel usar√° la primera definici√≥n encontrada para /home, ignorando la segunda.

Para dar Soluci√≥n:

Debemos eliminar o comentar la primera ruta y quedarte solo con la versi√≥n protegida con lockscreen y auth. As√≠:

    //  Eliminamos o comenta esta
    // Route::get('home', function(){
    //     return view('admin.dashboard');
    // })->middleware('auth');

Y dejamos √∫nicamente:

    //  Ruta protegida correctamente
    Route::middleware(['auth', 'lockscreen'])->group(function () {
        Route::get('/home', [HomeController::class, 'index'])->name('home');
    });


En el HomeController.php

Nos aseguramos de que el m√©todo index() devuelva correctamente el dashboard:

    public function index()
    {
        return view('admin.dashboard');
    }

En el m√©todo unlock() de LockscreenController

Cuando desbloqueamos, redirigimos a la ruta con nombre home:

    return redirect()->route('home');

El Resultado:

    /home mostrar√° el dashboard.

Esta ruta estar√° protegida tanto por auth como por tu middleware lockscreen.

El usuario solo accede tras autenticarse y desbloquear la sesi√≥n.



como observacin en nuestro editor nos marca el siguiente mensaje:
Undefined type 'Hash'

en la siguiente linea de codigo del LockscreenController:

    if (!\Hash::check($request->password, auth()->user()->password)) {
                return back()->withErrors(['password' => 'Contrase√±a incorrecta']);
            }


Ese mensaje "Undefined type 'Hash'" que vemos en nuestro editor VS Code u otro con inspecci√≥n de tipos,  debemos entender que no es un error de ejecuci√≥n de Laravel, sino una advertencia del sistema de an√°lisis est√°tico del editor que no encuentra la clase Hash referenciada con \Hash.

Aunque Laravel la reconoce porque el alias Hash est√° definido en el archivo config/app.php, el editor necesita la importaci√≥n expl√≠cita para reconocerla correctamente.

Soluci√≥n recomendada:

Agregamos esta l√≠nea al principio del archivo LockscreenController.php:

    use Illuminate\Support\Facades\Hash;

Y luego remueve la barra invertida en la l√≠nea donde usas Hash::check:

if (!Hash::check($request->password, auth()->user()->password)) {
    return back()->withErrors(['password' => 'Contrase√±a incorrecta']);
}

Como Resultado

    Laravel ya lo reconoc√≠a y funcionaba.

    Pero ahora nuestro editor tambi√©n sabr√° de d√≥nde viene Hash y no marcar√° advertencia alguna.


Manos a la obra.    


Tamien vamos apersonalizar nuestro mensaje de error.


@if ($errors->any())
    <div class="alert alert-danger text-center mt-3" role="alert" style="background-color: #f8d7da; color: #842029; border-radius: 8px; padding: 10px;">
        <i class="fa fa-exclamation-triangle"></i> {{ $errors->first('password') }}
    </div>
@endif

Pero ahora queremos acultarlo pasads 3 segundos.
@if ($errors->any())
    <div id="password-error" class="alert alert-danger text-center mt-3" role="alert" style="background-color: #f8d7da; color: #842029; border-radius: 8px; padding: 10px;">
        <i class="fa fa-exclamation-triangle"></i> {{ $errors->first('password') }}
    </div>

    <script>
        $(document).ready(function () {
            setTimeout(function () {
                $('#password-error').fadeOut('slow');
            }, 3000); // 3 segundos
        });
    </script>
@endif


Probamos la primera opcion perno no funciono con valilla javascrip por lo que probamos esta segunda opcion

@if ($errors->any())
    <div id="password-error" class="alert alert-danger text-center mt-3" role="alert" style="background-color: #f8d7da; color: #842029; border-radius: 8px; padding: 10px;">
        <i class="fa fa-exclamation-triangle"></i> {{ $errors->first('password') }}
    </div>

    <script>
        window.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => {
                const errorBox = document.getElementById('password-error');
                if (errorBox) {
                    errorBox.style.transition = 'opacity 1s ease';
                    errorBox.style.opacity = '0';
                    setTimeout(() => errorBox.remove(), 1000);
                }
            }, 3000); // 3 segundos
        });
    </script>
@endif


Algo a tener en ncunta es que si nuestro sistema detecta inactividad por cierto tiempo bloqueara en automatico nuestra sesi√≥n vamso a establecer un tiempode 5 minutos.

Gesti√≥n del tiempo de inactividad (inactivity timeout)
-----------------------------------
 
 
 Estrategia:

    Middleware para detectar inactividad.

    Javascript en el frontend para detectar tiempo sin interacci√≥n.

    Redirecci√≥n al /lockscreen si el usuario est√° inactivo.


Paso a paso:

A. En el middleware LockscreenMiddleware, agrega esto:

$inactivityLimit = 300; // 5 minutos
$lastActivity = session('last_activity');

if ($lastActivity && (time() - $lastActivity > $inactivityLimit)) {
    session(['locked' => true]);
}

session(['last_activity' => time()]);


Parece que este codigo esta fuera de lugar por loq ue lo vamos a agregrar en otro middleware



Para ello creamos nuestro middleware
Soluci√≥n estructurada
1. Crea un Middleware llamado InactivityMiddleware

Ejecuta en consola:

php artisan make:middleware InactivityMiddleware

Esto crea el archivo en:
app/Http/Middleware/InactivityMiddleware.php


2. Agrega el c√≥digo de control de inactividad en el middleware

<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class InactivityMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $inactivityLimit = 300; // 5 minutos en segundos
        $lastActivity = session('last_activity');

        if ($lastActivity && (time() - $lastActivity > $inactivityLimit)) {
            session(['locked' => true]);
        }

        session(['last_activity' => time()]);

        return $next($request);
    }
}

3. Registra el middleware en app/Http/Kernel.php

Busca el arreglo llamado $middlewareGroups['web'] o crea uno nuevo:

protected $middlewareGroups = [
    'web' => [
        // ...
        \App\Http\Middleware\InactivityMiddleware::class,
    ],
];

O si prefieres usarlo solo en rutas espec√≠ficas, registra en $routeMiddleware:

protected $routeMiddleware = [
    // ...
    'inactivity' => \App\Http\Middleware\InactivityMiddleware::class,
];

Y luego en web.php:

Route::middleware(['auth', 'inactivity', 'lockscreen'])->group(function () {
    Route::get('/home', [HomeController::class, 'index'])->name('home');
});

üîí Tu controlador LockscreenController queda perfecto como est√°.

No necesitas mover nada del controlador, ya que el control de la sesi√≥n por inactividad debe hacerse desde el middleware, para que se aplique en cada petici√≥n del usuario.


Tu controlador LockscreenController queda perfecto como est√°.

No necesitas mover nada del controlador, ya que el control de la sesi√≥n por inactividad debe hacerse desde el middleware, para que se aplique en cada petici√≥n del usuario.
üöÄ Resultado

    Cuando pasan m√°s de 5 minutos sin actividad, se marca session('locked') = true.

    El middleware lockscreen puede detectar esta bandera y redirigir al lockscreen.

    El controlador desbloquea correctamente si la contrase√±a es v√°lida.



B. Alternativamente (o adicionalmente) con JavaScript:

Agrega esto al layout general (layouts/app.blade.php o tu base):

<script>
let timeout;
const logoutTime = 5 * 60 * 1000; // 5 minutos

function resetTimer() {
    clearTimeout(timeout);
    timeout = setTimeout(() => {
        window.location.href = '/lockscreen';
    }, logoutTime);
}

['click', 'mousemove', 'keypress', 'scroll', 'touchstart'].forEach(evt =>
    document.addEventListener(evt, resetTimer)
);

resetTimer();
</script>

    Puedes hacer esto solo en las p√°ginas protegidas para no afectar otras.

‚úÖ ¬øQu√© ganamos?

    Mejor UX en la pantalla de bloqueo.

    Mensajes m√°s amigables e intuitivos.

    Seguridad reforzada por inactividad.

    Control visual completo sin salir de tu dise√±o.



Lo que falta ahora es que despues de que pase un tiempo determinado, la pantalla de lockscreen se active automaticamente por lo que modificamos el siguiente codigo:

<?php

namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class InactivityMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $inactivityLimit = 300; // 5 minutos en segundos
        $lastActivity = session('last_activity');

        if ($lastActivity && (time() - $lastActivity > $inactivityLimit)) {
            session(['locked' => true]);
        }

        session(['last_activity' => time()]);

        return $next($request);
    }
}

Por este:


namespace App\Http\Middleware;

use Closure;
use Illuminate\Http\Request;

class InactivityMiddleware
{
    public function handle(Request $request, Closure $next)
    {
        $inactivityLimit = 300; // 5 minutos en segundos
        $lastActivity = session('last_activity');

        if ($lastActivity && (time() - $lastActivity > $inactivityLimit)) {
            session(['locked' => true]);

            // Si est√° autenticado, redirige a la pantalla de bloqueo
            if (auth()->check()) {
                return redirect()->route('lockscreen');
            }
        }

        // Actualiza el tiempo de la √∫ltima actividad
        session(['last_activity' => time()]);

        return $next($request);
    }
}
